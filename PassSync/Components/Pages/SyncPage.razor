@page "/sync"
@implements IDisposable
@inject NavigationManager NavigationManager
@using Button = BlazorBootstrap.Button
@using InTheHand.Bluetooth
@using InTheHand.Net.Bluetooth
@using InTheHand.Net.Sockets
@using Microsoft.Maui.ApplicationModel
@using Microsoft.Maui.Controls
@using System.IO
@using System.Net.Sockets
@using PassSync.Components.Components
@using PassSync.Storage
@using System.Text

@if (!HasBluetoothPermission) {
    <p>Please enable bluetooth and fine location for this app in settings.</p>
}

@if (!IsBluetoothOn) {
    <p>Please enable bluetooth.</p>
}

@if (HasBluetoothPermission && IsBluetoothOn) {
    if (ConnectedDevice is null) {
        <div class="noConnectionDiv">
            <Button Color=ButtonColor.Primary @onclick=ConnectToDevice>Connect to Device</Button>
            Choose a device to sync with
        </div>
    }
    else {
        <div class="connectionDiv">
            <div class="deviceCard">
                <Card>
                    <CardHeader>
                        Device Connected
                    </CardHeader>
                    <CardBody>
                        <div>Name: @ConnectedDevice.DeviceName</div>
                        <div>Address: @ConnectedDevice.DeviceAddress</div>
                        <div>Type: @ConnectedDevice.ClassOfDevice.Device</div>
                        <div class="syncBtn">
                            <Button Color=ButtonColor.Secondary @onclick=ConnectToDevice>Another</Button>
                            <Button Color=ButtonColor.Primary @onclick=StartSync>Sync</Button>
                        </div>
                    </CardBody>
                </Card>
            </div>
        </div>
    }
}
else {
    <p>A bluetooth connection and fine location is needed to find devices and sync passwords across them.</p>
}

<Modal @ref=StatusModal IsVerticallyCentered=true UseStaticBackdrop=true CloseOnEscape=false ShowCloseButton=false OnHiding=@(() => IsCancelled = true)>
    <BodyTemplate>
        @switch (Status) {
            case TransferStatus.AttemptingClient:
                <text>Attempting as client</text>
                <Spinner />
                break;
            case TransferStatus.Listening:
                <text>Waiting for other device</text>
                <Spinner />
                break;
            case TransferStatus.IsClient:
                <text>Waiting for input on other device</text>
                <Spinner />
                break;
            case TransferStatus.Transferring:
                <text>Making sync transfer</text>
                <Spinner />
                break;
            case TransferStatus.Conflict:
                <text>Which version will you keep?</text>
                <InputRadioGroup @bind-Value=ConflictChosen>
                    @for (int i = 0; i < Conflicts.Count; i++) {
                        <InputRadio Value=i id=@($"conflict{i}")/>
                        <label for=@($"conflict{i}")>i</label>
                        <PasswordDisplay IsConflict=true Password=Conflicts[i] />
                    }
                </InputRadioGroup>
                break;
            case TransferStatus.Confirm:
                <text>Changes will make affect now (this cannot be undone)</text>
                break;
            default:
                <text>Unknown State</text>
                break;
        }
    </BodyTemplate>
    <FooterTemplate>
        @switch (Status) {
            case TransferStatus.AttemptingClient:
                break;
            case TransferStatus.Listening:
                <Button Color=ButtonColor.Secondary @onclick=StatusModal.HideAsync>Cancel</Button>
                break;
            case TransferStatus.IsClient:
                break;
            case TransferStatus.Transferring:
                break;
            case TransferStatus.Conflict:
                <Button Color=ButtonColor.Primary @onclick=@(() => IsConfirmed = true)>Confirm</Button>
                break;
            case TransferStatus.Confirm:
                <Button Color=ButtonColor.Secondary @onclick=StatusModal.HideAsync>Cancel</Button>
                <Button Color=ButtonColor.Primary @onclick=@(() => IsConfirmed = true)>Confirm</Button>
                break;
            default:
                <Button Color=ButtonColor.Secondary @onclick=StatusModal.HideAsync>Close</Button>
                break;
        }
    </FooterTemplate>
</Modal>

@code {
    private static readonly Guid AppGuid = new("{601CAE8F-89B7-47C1-A97E-981E6C3F69FF}");

    private bool HasBluetoothPermission { get; set; } = false;
    private bool IsBluetoothOn { get; set; } = false;

    private BluetoothDeviceInfo ConnectedDevice { get; set; } = null;

    private Modal StatusModal { get; set; }
    private TransferStatus Status { get; set; }
    private bool IsCancelled { get; set; }
    private bool IsConfirmed { get; set; }
    private List<Password> Conflicts { get; set; } = [];
    private int ConflictChosen { get; set; }

    protected override async Task OnInitializedAsync() {
        HasBluetoothPermission = await AskPermission();

        if (!HasBluetoothPermission)
            return;

        IsBluetoothOn = await Bluetooth.GetAvailabilityAsync();
        Bluetooth.AvailabilityChanged += OnBluetoothChanged;
    }

    public void Dispose() {
        Bluetooth.AvailabilityChanged -= OnBluetoothChanged;
    }

    private async Task<bool> AskPermission() {
        // this includes all permissions needed here: https://github.com/dotnet-bluetooth-le/dotnet-bluetooth-le?tab=readme-ov-file#android
        PermissionStatus status = await Permissions.CheckStatusAsync<Permissions.Bluetooth>();

        if (status == PermissionStatus.Granted)
            return true;

        if (Permissions.ShouldShowRationale<Permissions.Bluetooth>())
            await Application.Current.MainPage.DisplayAlert("Bluetooth Permission", "Bluetooth is necessary to sync across devices.", "Okay");

        status = await Permissions.RequestAsync<Permissions.Bluetooth>();
        return status == PermissionStatus.Granted;
    }

    private async void OnBluetoothChanged(object s, EventArgs e) {
        IsBluetoothOn = await Bluetooth.GetAvailabilityAsync();

        await InvokeAsync(StateHasChanged);
    }

    private async Task ConnectToDevice() {
        BluetoothDevicePicker devicePicker = new();
        ConnectedDevice = await devicePicker.PickSingleDeviceAsync();
    }

    private async Task StartSync() {
        Status = TransferStatus.AttemptingClient;
        await StatusModal.ShowAsync();

        // I do not want the user to be able to leave in the middle of communication
        // I have done everything I have thought of to prevent this
        ValueTask PreventNavigation(LocationChangingContext ctx) {
            ctx.PreventNavigation();
            return ValueTask.CompletedTask;
        }
        // once it is disposed on return, PreventNavigation will be unregistered
        using IDisposable handler = NavigationManager.RegisterLocationChangingHandler(PreventNavigation);

        if (!await BeClient())
            await BeHost();

        await StatusModal.HideAsync();
    }

    private async Task BeHost() {
        await SetStatus(TransferStatus.Listening);
        try {
            using BluetoothListener listener = new(AppGuid);
            listener.Start();

            IsCancelled = false;
            BluetoothClient client = null;
            // awesome, pending doesn't work on android, whoo!, source: https://github.com/inthehand/32feet/issues/337#issuecomment-1706223549
            if (!OperatingSystem.IsAndroid()) {
                while (!listener.Pending() && !IsCancelled)
                    await Task.Delay(25);
                if (!IsCancelled)
                    client = listener.AcceptBluetoothClient();
            }
            else {
                bool isAccepted = false;
                _ = Task.Run(() => {
                    client = listener.AcceptBluetoothClient();
                    isAccepted = true;
                });
                while (!isAccepted && !IsCancelled)
                    await Task.Delay(25);
            }

            if (IsCancelled) {
                // just in case since AcceptBluetoothClient is still running on android
                listener.Dispose();
                return;
            }

            await SetStatus(TransferStatus.Transferring);

            using Stream stream = client.GetStream();

            IEnumerable<Password> thisPasswords = await PasswordManager.GetAll();
            IEnumerable<Password> otherPasswords = await RecievePasswords(stream);
            List<Password> newList = new(thisPasswords.Concat(otherPasswords));

            // resolve conflicts
            for (int i = 0; i < newList.Count; i++) {
                Conflicts.Clear();
                Conflicts.Add(newList[i]);

                for (int j = i + 1; j < newList.Count; j++) {
                    // Register conflict
                    if (newList[i].IsConflict(newList[j])) {
                        Conflicts.Add(newList[j]);
                    }
                    // Remove conflicts and duplicates
                    if (newList[i].Id == newList[j].Id)
                        newList.RemoveAt(j);
                }

                if (Conflicts.Count > 1) {
                    await SetStatus(TransferStatus.Conflict);

                    IsConfirmed = false;
                    while (!IsConfirmed)
                        await Task.Delay(25);

                    newList[i] = Conflicts[ConflictChosen];
                }
            }

            await SetStatus(TransferStatus.Transferring);

            await SendPasswords(stream, newList);

            await SetStatus(TransferStatus.Confirm);

            IsCancelled = IsConfirmed = false;
            while (!IsCancelled && !IsConfirmed)
                await Task.Delay(25);

            if (IsConfirmed)
                await PasswordManager.ReplaceAll(newList);
        } catch (Exception e) {
            await Application.Current.MainPage.DisplayAlert(null, e.ToString(), "Okay");
        }
    }

    // returns false if it successfully determined that this device should be host
    private async Task<bool> BeClient() {
        try {
            using BluetoothClient client = new();
            await client.ConnectAsync(ConnectedDevice.DeviceAddress, AppGuid);

            if (!client.Connected)
                return false;

            await SetStatus(TransferStatus.IsClient);

            using Stream stream = client.GetStream();

            await SetStatus(TransferStatus.Transferring);

            await SendPasswords(stream, await PasswordManager.GetAll());
            IEnumerable<Password> passwords = await RecievePasswords(stream);

            await SetStatus(TransferStatus.Confirm);

            IsCancelled = IsConfirmed = false;
            while (!IsCancelled && !IsConfirmed)
                await Task.Delay(25);

            if (IsConfirmed)
                await PasswordManager.ReplaceAll(passwords);
        } catch (ArgumentOutOfRangeException) {
            // Bluetooth service was not found
            return false;
        } catch (Exception e) {
            await Application.Current.MainPage.DisplayAlert(null, e.ToString(), "Okay");
        }

        return true;
    }

    private async Task SetStatus(TransferStatus newStatus) {
        Status = newStatus;
        await InvokeAsync(StateHasChanged);
    }

    private async Task SendPasswords(Stream stream, IEnumerable<Password> passwords) {
        // write count of passwords
        await stream.WriteAsync(BitConverter.GetBytes(passwords.Count()));
        await stream.FlushAsync();

        foreach (Password password in passwords) {
            string xml = password.ToXml();
            byte[] bytes = Encoding.UTF8.GetBytes(xml);

            // write length of bytes and bytes
            await stream.WriteAsync(BitConverter.GetBytes(bytes.Length));
            await stream.WriteAsync(bytes);
            await stream.FlushAsync();
        }
    }

    private async Task<IEnumerable<Password>> RecievePasswords(Stream stream) {
        byte[] intBytes = new byte[4];

        // read count of passwords
        await stream.ReadExactlyAsync(intBytes, 0, 4);

        List<Password> passwords = [];
        for (int i = BitConverter.ToInt32(intBytes); i > 0; i--) {
            // read length of bytes and bytes
            await stream.ReadExactlyAsync(intBytes, 0, 4);
            byte[] bytes = new byte[BitConverter.ToInt32(intBytes)];
            await stream.ReadExactlyAsync(bytes, 0, bytes.Length);

            string xml = Encoding.UTF8.GetString(bytes);
            passwords.Add(Password.FromXml(xml));
        }
        return passwords;
    }

    private enum TransferStatus {
        AttemptingClient,
        Listening,
        UserPrompt,
        IsClient,
        Transferring,
        Conflict,
        Confirm
    }
}
