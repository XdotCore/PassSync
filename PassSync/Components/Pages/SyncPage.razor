@page "/sync"
@implements IDisposable
@inject NavigationManager NavigationManager
@using Button = BlazorBootstrap.Button
@using InTheHand.Bluetooth
@using InTheHand.Net.Bluetooth
@using InTheHand.Net.Sockets
@using Microsoft.Maui.ApplicationModel
@using Microsoft.Maui.Controls
@using System.IO
@using System.Net.Sockets
@using PassSync.Components.Components
@using PassSync.Storage

@if (!HasBluetoothPermission) {
    <p>Please enable bluetooth and fine location for this app in settings.</p>
}

@if (!IsBluetoothOn) {
    <p>Please enable bluetooth.</p>
}

@if (HasBluetoothPermission && IsBluetoothOn) {
    if (ConnectedDevice is null) {
        <div class="noConnectionDiv">
            <Button Color=ButtonColor.Primary @onclick=ConnectToDevice>Connect to Device</Button>
            Choose a device to sync with
        </div>
    }
    else {
        <div class="connectionDiv">
            <div class="deviceCard">
                <Card>
                    <CardHeader>
                        Device Connected
                    </CardHeader>
                    <CardBody>
                        <div>Name: @ConnectedDevice.DeviceName</div>
                        <div>Address: @ConnectedDevice.DeviceAddress</div>
                        <div>Type: @ConnectedDevice.ClassOfDevice.Device</div>
                        <div class="syncBtn">
                            <Button Color=ButtonColor.Secondary @onclick=ConnectToDevice>Another</Button>
                            <Button Color=ButtonColor.Primary @onclick=StartSync>Sync</Button>
                        </div>
                    </CardBody>
                </Card>
            </div>
        </div>
    }
}
else {
    <p>A bluetooth connection and fine location is needed to find devices and sync passwords across them.</p>
}

<Modal @ref=StatusModal IsVerticallyCentered=true UseStaticBackdrop=true CloseOnEscape=false ShowCloseButton=false OnHiding=@(() => IsCancelled = true)>
    <BodyTemplate>
        @switch (Status) {
            case TransferStatus.AttemptingClient:
                <text>Attempting as client</text>
                <Spinner />
                break;
            case TransferStatus.Listening:
                <text>Waiting for other device</text>
                <Spinner />
                break;
            case TransferStatus.UserPrompt:
                <text>Choose which device to take from</text>
                <div>
                    <InputRadioGroup @bind-Value=MergeDevice>
                        <div>
                            <InputRadio Value=DeviceChoice.This id="thisDevice" />
                            <label for="thisDevice">Take all from this device</label>
                        </div>
                        <div>
                            <InputRadio Value=DeviceChoice.Other id="otherDevice" />
                            <label for="otherDevice">Take all from the other device</label>
                        </div>
                        <div>
                            <InputRadio Value=DeviceChoice.Combined id="combineDevice" />
                            <label for="combineDevice">Combine from both devices (may require resolving conflicts)</label>
                        </div>
                    </InputRadioGroup>
                </div>
                break;
            case TransferStatus.IsClient:
                <text>Waiting for input on other device</text>
                <Spinner />
                break;
            case TransferStatus.Transferring:
                <text>Making sync transfer</text>
                <Spinner />
                break;
            case TransferStatus.Conflict:
                <text>Which version will you keep?</text>
                <div>
                    This:
                    <PasswordDisplay Password=ConflictHost IsConflict=true />
                </div>
                <div>
                    Other:
                    <PasswordDisplay Password=ConflictClient IsConflict=true />
                </div>
                break;
            case TransferStatus.Confirm:
                <text>Changes will make affect now</text>
                break;
            default:
                <text>Unknown State</text>
                break;
        }
    </BodyTemplate>
    <FooterTemplate>
        @switch (Status) {
            case TransferStatus.AttemptingClient:
                break;
            case TransferStatus.Listening:
                <Button Color=ButtonColor.Secondary @onclick=StatusModal.HideAsync>Cancel</Button>
                break;
            case TransferStatus.UserPrompt:
                <Button Color=ButtonColor.Secondary @onclick=StatusModal.HideAsync>Cancel</Button>
                <Button Color=ButtonColor.Primary @onclick=@(() => IsConfirmed = true)>Confirm</Button>
                break;
            case TransferStatus.IsClient:
                break;
            case TransferStatus.Transferring:
                break;
            case TransferStatus.Conflict:
                <Button Color=ButtonColor.Secondary @onclick=StatusModal.HideAsync>Cancel</Button>
                <Button Color=ButtonColor.Primary>This</Button>
                <Button Color=ButtonColor.Primary>Other</Button>
                break;
            case TransferStatus.Confirm:
                <Button Color=ButtonColor.Secondary @onclick=StatusModal.HideAsync>Cancel</Button>
                <Button Color=ButtonColor.Primary>Confirm</Button>
                break;
            default:
                <Button Color=ButtonColor.Secondary @onclick=StatusModal.HideAsync>Close</Button>
                break;
        }
    </FooterTemplate>
</Modal>

@code {
    private static readonly Guid AppGuid = new("{601CAE8F-89B7-47C1-A97E-981E6C3F69FF}");

    private bool HasBluetoothPermission { get; set; } = false;
    private bool IsBluetoothOn { get; set; } = false;

    private BluetoothDeviceInfo ConnectedDevice { get; set; } = null;
    private string Message { get; set; }

    private Modal StatusModal { get; set; }
    private TransferStatus Status { get; set; }
    private bool IsCancelled { get; set; }
    private bool IsConfirmed { get; set; }
    private DeviceChoice MergeDevice { get; set; }
    private Password ConflictHost { get; set; }
    private Password ConflictClient { get; set; }

    protected override async Task OnInitializedAsync() {
        HasBluetoothPermission = await AskPermission();

        if (!HasBluetoothPermission)
            return;

        IsBluetoothOn = await Bluetooth.GetAvailabilityAsync();
        Bluetooth.AvailabilityChanged += OnBluetoothChanged;
    }

    public void Dispose() {
        Bluetooth.AvailabilityChanged -= OnBluetoothChanged;
    }

    private async Task<bool> AskPermission() {
        // this includes all permissions needed here: https://github.com/dotnet-bluetooth-le/dotnet-bluetooth-le?tab=readme-ov-file#android
        PermissionStatus status = await Permissions.CheckStatusAsync<Permissions.Bluetooth>();

        if (status == PermissionStatus.Granted)
            return true;

        if (Permissions.ShouldShowRationale<Permissions.Bluetooth>())
            await Application.Current.MainPage.DisplayAlert("Bluetooth Permission", "Bluetooth is necessary to sync across devices.", "Okay");

        status = await Permissions.RequestAsync<Permissions.Bluetooth>();
        return status == PermissionStatus.Granted;
    }

    private async void OnBluetoothChanged(object s, EventArgs e) {
        IsBluetoothOn = await Bluetooth.GetAvailabilityAsync();

        await InvokeAsync(StateHasChanged);
    }

    private async Task ConnectToDevice() {
        BluetoothDevicePicker devicePicker = new();
        ConnectedDevice = await devicePicker.PickSingleDeviceAsync();
    }

    private async Task StartSync() {
        Status = TransferStatus.AttemptingClient;
        await StatusModal.ShowAsync();

        // I do not want the user to be able to leave in the middle of communication
        // I have done everything I have thought of to prevent this
        ValueTask PreventNavigation(LocationChangingContext ctx) {
            ctx.PreventNavigation();
            return ValueTask.CompletedTask;
        }
        // once it is disposed on return, PreventNavigation will be unregistered
        using IDisposable handler = NavigationManager.RegisterLocationChangingHandler(PreventNavigation);

        if (!await BeClient())
            await BeHost();

        await StatusModal.HideAsync();
    }

    private async Task BeHost() {
        await SetStatus(TransferStatus.Listening);
        try {
            using BluetoothListener listener = new(AppGuid);
            listener.Start();

            IsCancelled = false;
            BluetoothClient client = null;
            // awesome, pending doesn't work on android, whoo!, source: https://github.com/inthehand/32feet/issues/337#issuecomment-1706223549
            if (!OperatingSystem.IsAndroid()) {
                while (!listener.Pending() && !IsCancelled)
                    await Task.Delay(25);
                if (!IsCancelled)
                    client = listener.AcceptBluetoothClient();
            }
            else {
                bool isAccepted = false;
                _ = Task.Run(() => {
                    client = listener.AcceptBluetoothClient();
                    isAccepted = true;
                });
                while (!isAccepted && !IsCancelled)
                    await Task.Delay(25);
            }

            if (IsCancelled) {
                // just in case since AcceptBluetoothClient is still running on android
                listener.Dispose();
                return;
            }

            await SetStatus(TransferStatus.UserPrompt);

            IsCancelled = IsConfirmed = false;
            while (!IsCancelled && !IsConfirmed)
                await Task.Delay(25);

            if (IsCancelled)
                return;

            await SetStatus(TransferStatus.Transferring);

            using Stream stream = client.GetStream();

            await stream.WriteAsync(new byte[1] { (byte)MergeDevice });

            switch (MergeDevice) {
                case DeviceChoice.This: {

                } break;
                case DeviceChoice.Other: {

                } break;
                case DeviceChoice.Combined: {

                } break;
            }
        } catch (Exception e) {
            await Application.Current.MainPage.DisplayAlert(null, e.ToString(), "Okay");
        }
    }

    // returns false if it successfully determined that this device should be host
    private async Task<bool> BeClient() {
        try {
            using BluetoothClient client = new();
            await client.ConnectAsync(ConnectedDevice.DeviceAddress, AppGuid);

            if (!client.Connected)
                return false;

            await SetStatus(TransferStatus.IsClient);

            using Stream stream = client.GetStream();

            byte[] mergeDevice = new byte[1];
            await stream.ReadExactlyAsync(mergeDevice, 0, 1);
            MergeDevice = (DeviceChoice)mergeDevice[0];

            await SetStatus(TransferStatus.Transferring);

            // This and other are reversed relative to the client
            switch (MergeDevice) {
                case DeviceChoice.This: {

                } break;
                case DeviceChoice.Other: {

                } break;
                case DeviceChoice.Combined: {
                    
                } break;
            }
        } catch (ArgumentOutOfRangeException) {
            // Bluetooth service was not found
            return false;
        } catch (Exception e) {
            await Application.Current.MainPage.DisplayAlert(null, e.ToString(), "Okay");
        }

        return true;
    }

    private async Task SetStatus(TransferStatus newStatus) {
        Status = newStatus;
        await InvokeAsync(StateHasChanged);
    }

    private enum TransferStatus {
        AttemptingClient,
        Listening,
        UserPrompt,
        IsClient,
        Transferring,
        Conflict,
        Confirm
    }

    private enum DeviceChoice : byte {
        Combined,
        This,
        Other
    }
}
